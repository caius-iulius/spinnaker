# TODO:Questo file andrà copiato in una stringa in defs.rs

# operatori di base
def pub (+) = \a,b->_addInt(a,b)
def pub (-) = \a,b->_subInt(a,b)
def pub (*) = \a,b->_mulInt(a,b)
def pub (/) = \a,b->_divInt(a,b)
def pub (<) = \a,b->_greInt(b,a)
def pub (>) = \a,b->_greInt(a,b)
def pub (=) = \a,b->_equInt(a,b)
def pub (!=)= \a,b->_neqInt(a,b)
def pub (<=)= \a,b->_leqInt(a,b)
def pub (>=)= \a,b->_leqInt(b,a)

# operatori funzionali
# NOTA: In F# (e OCaml in un certo senso) gli operatori di composizione sono (>>) e (<<) invece di (|>) e (<|).
# Oltretutto (|>) e (<|) sono pipe e non composizioni,ma (|>) è associativa a sinistra. Bisogna considerare vantaggi e svantaggi dei vari approcci in un sistema associativo a destra.
#   In F#:
#   def (|>) = \x,f{f x}
# In molti casi la composizione è rappresentata da un punto,ma al momento sto pensando di usarlo per i namespace e le struct

def pub (|>) = \f,g,x->g(f x)
def pub (<|) = \f,g,x->f(g x)

# questi in forse
def pub (|->) = \x,f->f x

# altra roba utile
def pub ($) = \a,b->a b
def pub flip = \f,x,y->f y x
def pub curry = \f,x,y->f(x,y)
def pub uncurry = \f,(x,y)->f x y

mod pub List {
    data pub List a
        = Nil
        | Cons a (List a)

    def pub reverse = \acc, l ->
        put l
        | Nil -> acc
        | Cons x xs -> reverse (Cons x acc) xs

    def pub head = \Cons x xs -> x
    def pub tail = \Cons x xs -> xs
    def pub last = \l ->
        put l
        | Cons x Nil -> x
        | Cons x xs -> last xs

    def pub map = \f, l ->
        put l
        | Nil -> Nil
        | Cons x xs -> Cons (f x) (map f xs)

    def pub foldl = \f, s, l ->
        put l
        | Nil -> s
        | Cons x xs -> foldl f (f s x) xs

    def pub foldr = \f, s, l ->
        put l
        | Nil -> s
        | Cons x xs -> f x (foldr f s xs)

    def pub length = \l ->
        put l
        | Nil -> 0
        | Cons _ xs -> 1 + length xs

    def pub zip = \l, l' ->
        put (l, l')
        | (Nil, _) -> Nil
        | (_, Nil) -> Nil
        | (Cons x xs, Cons x' xs') -> Cons (x, x') (zip xs xs')

    def pub zipWith = \f, l, l' ->
        put (l, l')
        | (Nil, _) -> Nil
        | (_, Nil) -> Nil
        | (Cons x xs, Cons x' xs') -> Cons (f x x') (zipWith f xs xs')

    def pub (++) = \l, l' ->
        put l
        | Nil -> l'
        | Cons x xs -> Cons x (xs ++ l')

    def pub (..) = \from, to ->
        put from >= to
        | True -> Nil
        | _ -> Cons from ((from+1)..to)
}
use pub List

mod pub IO {
    def pub putChr = _putChr
    def pub getChr = _getChr
    def pub putStr = \s ->
        put s
        | Nil -> ()
        | Cons c cs ->
            let _ = (putChr c, putStr cs) -> ()
    def pub putStrLn = \s ->
        let _ = (putStr s, putChr 10) -> ()
}
use pub IO

mod pub Utility {
    def writeDigit = \i -> 48 + i

    def writeNonNeg = \i ->
        put i < 10
        | True -> Cons (writeDigit i) Nil
        | _ ->
            let div10 = i/10 ->
            let prev = writeNonNeg div10 ->
            prev ++ Cons (writeDigit $ i - div10*10) Nil

    def pub writeInt = \i ->
        put i < 0
        | True -> Cons 45 (writeNonNeg (0-i))
        | _ -> writeNonNeg i

    def writeListIntInternal = \l ->
        put l
        | Nil -> Cons 93 Nil
        | Cons x Nil -> writeInt x ++ Cons 93 Nil
        | Cons x xs -> writeInt x ++ Cons 44 (Cons 32 Nil) ++ writeListIntInternal xs

    def pub writeListInt = \l -> Cons 91 (writeListIntInternal l)
}

# NOTA: Ovviamente serve tanta roba, come le funzioni liftM2, cose su liste, monadi, moduli...
