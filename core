# TODO:Questo file andrà copiato in una stringa nel compilatore

mod Builtins {
    # Combinatori primitivi

    ext pub _addInt : Int, Int -> Int
    ext pub _subInt : Int, Int -> Int
    ext pub _mulInt : Int, Int -> Int
    ext pub _divInt : Int, Int -> Int
    ext pub _equInt : Int, Int -> Bool
    ext pub _neqInt : Int, Int -> Bool
    ext pub _leqInt : Int, Int -> Bool
    ext pub _greInt : Int, Int -> Bool

    ext pub _convItoC : Int -> Chr
    ext pub _convCtoI : Chr -> Int

    ext pub _putChr : Chr, RealWorld_ -> RealWorld_
    ext pub _getChr : RealWorld_ -> (Chr, RealWorld_)
    ext pub _exit : RealWorld_ -> RealWorld_
}

def pub (|>) : forall a b c. (a -> b) -> (b -> c) -> (a -> c)
    = \f,g,x->g(f x)
def pub (<|) : forall a b c. (b -> c) -> (a -> b) -> (a -> c)
    = \f,g,x->f(g x)
def pub (|->) : forall a b. a -> (a -> b) -> b
    = \x,f->f x
def pub ($) : forall a b. (a -> b) -> a -> b
    = \a,b->a b
def pub flip : forall a b c. (a -> b -> c) -> b -> a -> c
    = \f,x,y->f y x
def pub curry : forall a b c. ((a, b) -> c) -> a -> b -> c
    = \f,x,y->f(x,y)
def pub uncurry : forall a b c. (a -> b -> c) -> (a, b) -> c
    = \f,(x,y)->f x y
def pub id : forall a. a -> a
    = \x->x
def pub const : forall a b. a -> b -> a
    = \x,_->x
def pub fst : forall a b. (a, b) -> a
    = \(a,_)->a
def pub snd : forall a b. (a, b) -> b
    = \(_,b)->b

mod BoolCore {
    def pub (&&) : Bool -> Bool -> Bool
        = \a, b -> put (a, b)
        | (True, True) -> True
        | _ -> False

    def pub (||) : Bool -> Bool -> Bool
        = \a, b -> put (a, b)
        | (False, False) -> False
        | _ -> True

    def pub not : Bool -> Bool
        = \a -> put a
        | True -> False
        | False -> True
} use pub BoolCore

mod NumCore {
    # Relazioni e istanze dei numerici builtin

    rel pub Num a =
        (+) : a -> a -> a,
        (-) : a -> a -> a,
        (*) : a -> a -> a,
        (/) : a -> a -> a,
        fromInt : Int -> a

    rel pub Eq a =
        (==) : a -> a -> Bool,
        (!=) : a -> a -> Bool

    inst forall a b. {Eq a, Eq b} => Eq (a, b) {
        def (==) = \(a, b), (a', b') -> (a == a') && (b == b')
        def (!=) = \a, b -> not $ a == b
    }


    rel pub {Eq a} => Ord a =
        (<) : a -> a -> Bool,
        (>) : a -> a -> Bool,
        (>=) : a -> a -> Bool,
        (<=) : a -> a -> Bool

    rel pub Enum a =
        fromEnum : a -> Int,
        toEnum : Int -> a

    use Builtins

    inst Num Int {
        def (+) = _addInt
        def (-) = _subInt
        def (*) = _mulInt
        def (/) = _divInt
        def fromInt = id
    }

    inst Eq Int {
        def (==) = _equInt
        def (!=) = _neqInt
    }

    inst Ord Int {
        def (<) = \a,b->_greInt b a
        def (>) = _greInt
        def (<=)= _leqInt
        def (>=)= \a,b->_leqInt b a
    }

    inst Enum Int {
        def toEnum = id
        def fromEnum = id
    }

    inst Enum Chr {
        def toEnum = _convItoC
        def fromEnum = _convCtoI
    }
} use pub NumCore

mod MonadCore {
    # Definizione di Monade e delle strutture da cui dipende

    rel pub Functor f =
        # LAWS
        # 1. fmap id = id
        # 2. fmap (f <| g) = fmap f <| fmap g
        fmap : forall a b. (a -> b) -> f a -> f b

    rel pub {Functor m} => Monad m =
        # LAWS
        # 1. bind (return a) k = k a
        # 2. bind m return = m
        # 3. bind m (\x -> bind (k x) h) = bind (bind m k) h
        # 4. fmap f m = bind m (\x -> return f x)
        return : forall a. a -> m a,
        bind : forall a b. m a -> (a -> m b) -> m b

    def pub (>>=) : forall m a b. {Monad m} => m a -> (a -> m b) -> m b
        = bind
    def pub (>>) : forall m a b. {Monad m} => m a -> m b -> m b
        = \m, m' -> m >>= \_ -> m'

    inst forall m. {Monad m} => Functor m {
        def fmap = \f, m -> bind m (\x->return (f x))
    }
} use pub MonadCore

mod ListCore {
    # Definizione di lista e alcuni primitivi molto utili

    data pub List a
        = Nil
        | Cons a (List a)

    def pub (::) : forall a. a -> List a -> List a
        = Cons

    def pub map : forall a b. (a -> b) -> List a -> List b
        = \f, l -> put l
        | Nil -> Nil
        | Cons x xs -> f x :: map f xs

    inst Functor List {def fmap = map}

    def pub (++) : forall a. List a -> List a -> List a
        = \l, l' -> put l
        | Nil -> l'
        | Cons x xs -> x :: (xs ++ l')

    inst Monad List {
        def return = \x -> x :: Nil
        def bind = \l, f->
            put l
            | Nil -> Nil
            | Cons x xs -> f x ++ bind xs f
    }

    def pub head : forall a. List a -> a
        = \Cons x xs -> x
    def pub tail : forall a. List a -> List a
        = \Cons x xs -> xs
    def pub last : forall a. List a -> a
        = \l -> put l
        | Cons x Nil -> x
        | Cons x xs -> last xs
    def pub init : forall a. List a -> List a
        = \l -> put l
        | Cons x Nil -> Nil
        | Cons x xs -> x :: (init xs)

    def reverseAux = \acc, l ->
        put l
        | Nil -> acc
        | Cons x xs -> reverseAux (x :: acc) xs
    def pub reverse : forall a. List a -> List a
        = reverseAux Nil

    def pub foldl : forall a s. (s -> a -> s) -> s -> List a -> s
        = \f, s, l -> put l
        | Nil -> s
        | Cons x xs -> foldl f (f s x) xs

    def pub foldr : forall s a. (a -> s -> s) -> s -> List a -> s
        = \f, s, l -> put l
        | Nil -> s
        | Cons x xs -> f x (foldr f s xs)

    def lengthAux = \n, l -> put l
        | Nil -> n
        | Cons _ xs -> lengthAux (n + 1) xs
    def pub length : forall a. List a -> Int
        = lengthAux 0

    def pub zip : forall a b. List a -> List b -> List (a, b)
        = \l, l' -> put (l, l')
        | (Nil, _) -> Nil
        | (_, Nil) -> Nil
        | (Cons x xs, Cons x' xs') -> (x, x') :: zip xs xs'

    def pub zipWith : forall a b c. (a -> b -> c) -> List a -> List b -> List c
        = \f, l, l' -> put (l, l')
        | (Nil, _) -> Nil
        | (_, Nil) -> Nil
        | (Cons x xs, Cons x' xs') -> f x x' :: zipWith f xs xs'
} use pub ListCore

mod ShowCore {
    # Definizione di Show e delle sue istanze sui tipi builtin

    rel pub Show a = show : a -> List Chr

    def pub strNil : List Chr = Nil
    inst Show () {
        def show = \() -> '('::')':: Nil
    }

    inst Show Bool {
        def show = \b -> put b
            | True -> 'T'::'r'::'u'::'e'::Nil
            | False -> 'F'::'a'::'l'::'s'::'e'::Nil
    }

    def showDigit : Int -> Chr = \i -> toEnum (48 + i)

    def showNonNegAux = \s, i -> put (i < 10)
        | True -> showDigit i :: s
        | _ ->
            let div10 = i/10 ->
            let mod10 = i - div10*10 ->
            showNonNegAux (showDigit mod10 :: s) div10
    def showNonNeg = showNonNegAux Nil

    def showInt = \i ->
        put i < 0
        | True -> '-' :: showNonNeg (0-i)
        | _ -> showNonNeg i

    inst Show Int { def show = showInt }

    def escapeChr = \c -> put c
        | '\n' -> '\\'::'n'::Nil
        | '\\' -> '\\'::'\\'::Nil
        | '\'' -> '\\'::'\''::Nil
        | '"' -> '\\'::'"'::Nil
        | _ -> c::Nil #Solo se 32 <= fromEnum c <= 126

    inst Show Chr {
        def show = \c -> Cons '\'' (escapeChr c) ++ ('\''::Nil)
    }

    inst Show (List Chr) {
        def show = \l -> Cons '"' (foldl (\s, c -> s ++ escapeChr c) Nil l) ++ ('"'::Nil)
    }

    def showListAux = \l ->
        put l
        | Nil -> ']' :: Nil
        | Cons x Nil -> show x ++ (']' :: Nil)
        | Cons x xs -> show x ++ Cons ',' (Cons ' ' Nil) ++ showListAux xs

    def showList = \l -> '[' :: showListAux l

    inst forall a. {Show a} => Show (List a) {
        def show = showList
    }

    inst forall a b. {Show a, Show b} => Show (a, b) {
        def show = \(a, b) -> '(' :: show a ++ (','::Nil) ++ show b ++ (')'::Nil)
    }
} use pub ShowCore

mod pub State {
    # Definizione del monade State, usato per definire IO

    data pub State s a = State (s -> (a, s))

    inst forall s. Functor (State s) {
        def fmap = \f, State st -> State (\s->
                let (a, s') = st s ->
                    (f a, s')
            )
    }

    inst forall s. Monad (State s) {
        def return = \a -> State(\s -> (a, s))
        def bind = \State st, sf -> State (\s->
                let (a, s') = st s ->
                let State st' = sf a ->
                st' s'
            )
    }

    def pub gets : forall s. State s s
        = State (\s->(s, s))
    def pub puts : forall s. s -> State s ()
        = \ns -> State (\_->((), ns))

    def pub runState : forall s a. s -> State s a -> (a, s)
        = \is, State st -> st is
}

mod IOCore {
    # Definizione del monade IO e delle operazioni primitive

    data pub IO a = IO (State.State RealWorld_ a)

    inst Functor IO {
        def fmap = \f, IO s -> IO (fmap f s)
    }
    inst Monad IO {
        def return = \a -> IO (return a)
        def bind = \IO s, iof -> IO (bind s (\a ->
            let IO b = iof a -> b))
    }

    mod pub UnsafeIO {
        use Builtins

        def pub putChr = _putChr
        def pub getChr = _getChr
        def pub exit = _exit

        def pub putStr : List Chr -> RealWorld_ -> RealWorld_
            = \s, rw -> put s
            | Nil -> rw
            | Cons c cs ->
                let rw' = putChr c rw ->
                putStr cs rw'
        def pub putStrLn = \s, rw ->
            let rw' = putStr s rw ->
            putChr '\n' rw'
        def pub getLn = \rw ->
            put getChr rw
            | ('\n', rw') -> (Nil, rw')
            | (c, rw') ->
                let (s, rw'') = getLn rw' ->
                (c :: s, rw'')

        def pub runIO = \IO s -> let (a, s') = State.runState RealWorld_ s -> s'
    }

    def pub putChr : Chr -> IO ()
        = \c -> IO(State.State (\s->(() , UnsafeIO.putChr c s)))
    def pub getChr : IO Chr
        = IO(State.State UnsafeIO.getChr)
    def pub putStr : List Chr -> IO ()
        = \l -> IO(State.State(\s->((), UnsafeIO.putStr l s)))
    def pub putStrLn : List Chr -> IO ()
        = \l -> IO(State.State(\s->((), UnsafeIO.putStrLn l s)))
    def pub getLn : IO (List Chr)
        = IO(State.State UnsafeIO.getLn)

    def pub print : forall a. {Show a} => a -> IO ()
        = show |> putStrLn

    def errorAux : forall a. List Chr -> RealWorld_ -> a
        = \s, rw -> errorAux s (UnsafeIO.exit (UnsafeIO.putStrLn s rw))
    def pub error : forall a. List Chr -> a
        = \s -> errorAux ('e'::'r'::'r'::'o'::'r'::':'::' '::s) RealWorld_
} use pub IOCore

mod pub Monad {
    def pub sequence : forall m a. {Monad m} => List (m a) -> m (List a)
        = \lm -> put lm
        | Nil -> return Nil
        | Cons m ms -> m >>= \a -> sequence ms >>= \as -> return (a :: as)

    rel pub {Monad m} => MonadPlus m =
        # LAWS
        # 1) MONOID
        # 1.1) mplus mzero a = a
        # 1.2) mplus a mzero = a
        # 1.3) mplus (mplus a b) c = mplus a (mplus b c)
        # 2) mzero >>= f = mzero
        # 3) m >> mzero = mzero
        mzero : forall a. m a,
        mplus : forall a. m a -> m a -> m a

    def pub guard : forall m. {MonadPlus m} => Bool -> m ()
        = \b -> put b
        | True -> return ()
        | False -> mzero

    inst MonadPlus List {
        def mzero = Nil
        def mplus = (++)
    }

    rel pub {Monad m} => MonadFail m =
        # Se {MonadPlus m} si può considerare: mzero = fail "mzero"
        fail : forall a. List Chr -> m a

    inst MonadFail IO {
        def fail = error
    }
}

def pub max : forall a. {Ord a} => a -> a -> a
    = \a, b -> put a > b
    | True -> a
    | False -> b
def pub any : forall a. (a -> Bool) -> List a -> Bool
    = \bf, l -> put l
    | Nil -> False
    | Cons x xs -> put bf x
        | True -> True
        | _ -> any bf xs
def pub elem : forall a. {Eq a} => a -> List a -> Bool
    = \x -> any ((==) x)
def pub nth : forall a. Int -> List a -> a
    = \n, l -> put n
    | 0 -> head l
    | _ -> nth (n - 1) (tail l)
def innerdotdot = \from, to ->
    put from >= to
    | True -> Nil
    | _ -> toEnum from :: innerdotdot (from+1) to
def pub (..) : forall a. {Enum a} => a -> a -> List a
    = \from, to ->
        innerdotdot (fromEnum from) (fromEnum to)
def pub (..=) : forall a. {Enum a} => a -> a -> List a
    = \from, to ->
        innerdotdot (fromEnum from) (fromEnum to + 1)
