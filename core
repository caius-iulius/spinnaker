# TODO:Questo file andrÃ  copiato in una stringa nel compilatore

ext pub _addInt : (Int, Int) -> Int
ext pub _subInt : (Int, Int) -> Int
ext pub _mulInt : (Int, Int) -> Int
ext pub _divInt : (Int, Int) -> Int
ext pub _equInt : (Int, Int) -> Bool
ext pub _neqInt : (Int, Int) -> Bool
ext pub _leqInt : (Int, Int) -> Bool
ext pub _greInt : (Int, Int) -> Bool
ext pub _convItoC : Int -> Chr
ext pub _convCtoI : Chr -> Int
ext pub _putChr : (Chr, RealWorld_) -> RealWorld_
ext pub _getChr : RealWorld_ -> (Chr, RealWorld_)

def pub (|>) = \f,g,x->g(f x)
def pub (<|) = \f,g,x->f(g x)
def pub (|->) = \x,f->f x
def pub ($) = \a,b->a b
def pub flip = \f,x,y->f y x
def pub curry = \f,x,y->f(x,y)
def pub uncurry = \f,(x,y)->f x y
def pub id = \x->x
def pub const = \x,_->x
def pub fst = \(a,_)->a
def pub snd = \(_,a)->a

mod Numerics {
    rel pub Num a =
        (+) : a -> a -> a,
        (-) : a -> a -> a,
        (*) : a -> a -> a,
        (/) : a -> a -> a

    rel pub Eq a =
        (==) : a -> a -> Bool,
        (!=) : a -> a -> Bool

    rel pub {Eq a} => Ord a =
        (<) : a -> a -> Bool,
        (>) : a -> a -> Bool,
        (>=) : a -> a -> Bool,
        (<=) : a -> a -> Bool

    rel pub Enum a =
        fromEnum : a->Int,
        toEnum : Int->a


    inst Num Int {
        def (+) = \a,b->_addInt(a,b)
        def (-) = \a,b->_subInt(a,b)
        def (*) = \a,b->_mulInt(a,b)
        def (/) = \a,b->_divInt(a,b)
    }

    inst Eq Int {
        def (==) = \a,b->_equInt(a,b)
        def (!=)= \a,b->_neqInt(a,b)
    }

    inst Ord Int {
        def (<) = \a,b->_greInt(b,a)
        def (>) = \a,b->_greInt(a,b)
        def (<=)= \a,b->_leqInt(a,b)
        def (>=)= \a,b->_leqInt(b,a)
    }

    inst Enum Int {
        def toEnum = id
        def fromEnum = id
    }

    inst Enum Chr {
        def toEnum = _convItoC
        def fromEnum = _convCtoI
    }
} use pub Numerics

mod Monad {
    rel pub Functor f = fmap : forall a b. (a -> b) -> f a -> f b
    rel pub {Functor m} => Monad m =
        return : forall a. a -> m a,
        bind : forall a b. m a -> (a -> m b) -> m b

    def pub (>>=) = bind
    def pub (>>) = \m, m' -> m >>= \_ -> m'

    inst forall m. {Monad m} => Functor m {
        def fmap = \f, m -> bind m (\x->return (f x))
    }
} use pub Monad

mod List {
    data pub List a
        = Nil
        | Cons a (List a)

    def pub (::) = Cons

    def reverseAux = \acc, l ->
        put l
        | Nil -> acc
        | Cons x xs -> reverseAux (x :: acc) xs
    def pub reverse = reverseAux Nil

    def pub head = \Cons x xs -> x
    def pub tail = \Cons x xs -> xs
    def pub last = \l ->
        put l
        | Cons x Nil -> x
        | Cons x xs -> last xs

    def pub map = \f, l ->
        put l
        | Nil -> Nil
        | Cons x xs -> f x :: map f xs
    inst Functor List {def fmap = map}

    def pub foldl = \f, s, l ->
        put l
        | Nil -> s
        | Cons x xs -> foldl f (f s x) xs

    def pub foldr = \f, s, l ->
        put l
        | Nil -> s
        | Cons x xs -> f x (foldr f s xs)

    def lengthAux = \n, l -> put l
        | Nil -> n
        | Cons _ xs -> lengthAux (n + 1) xs
    def pub length = lengthAux 0

    def pub zip = \l, l' ->
        put (l, l')
        | (Nil, _) -> Nil
        | (_, Nil) -> Nil
        | (Cons x xs, Cons x' xs') -> (x, x') :: zip xs xs'

    def pub zipWith = \f, l, l' ->
        put (l, l')
        | (Nil, _) -> Nil
        | (_, Nil) -> Nil
        | (Cons x xs, Cons x' xs') -> f x x' :: zipWith f xs xs'

    def pub (++) = \l, l' ->
        put l
        | Nil -> l'
        | Cons x xs -> x :: (xs ++ l')

    def innerdotdot = \from, to ->
        put from >= to
        | True -> Nil
        | _ -> toEnum from :: innerdotdot (from+1) to
    def pub (..) : forall a. {Enum a} => a -> a -> List a
        = \from, to ->
            innerdotdot (fromEnum from) (fromEnum to)
    def pub (..=) : forall a. {Enum a} => a -> a -> List a
        = \from, to ->
            innerdotdot (fromEnum from) (fromEnum to + 1)

    def pub sequence = \lm -> put lm
        | Nil -> return Nil
        | Cons m ms -> m >>= \a -> sequence ms >>= \as -> return (a :: as)
} use pub List

mod Show {
    rel pub Show a = show : a -> List Chr

    inst Show () {
        def show = \() -> '('::')':: Nil
    }

    inst Show Bool {
        def show = \b -> put b
            | True -> 'T'::'r'::'u'::'e'::Nil
            | False -> 'F'::'a'::'l'::'s'::'e'::Nil
    }

    def showDigit : Int -> Chr = \i -> toEnum (48 + i)

    def showNonNegAux = \s, i -> put (i < 10)
        | True -> showDigit i :: s
        | _ ->
            let div10 = i/10 ->
            let mod10 = i - div10*10 ->
            showNonNegAux (showDigit mod10 :: s) div10
    def showNonNeg = showNonNegAux Nil

    def showInt = \i ->
        put i < 0
        | True -> '-' :: showNonNeg (0-i)
        | _ -> showNonNeg i

    inst Show Int { def show = showInt }

    def escapeChr = \c -> put c
        | '\n' -> '\\'::'n'::Nil
        | '\\' -> '\\'::'\\'::Nil
        | '\'' -> '\\'::'\''::Nil
        | '"' -> '\\'::'"'::Nil
        | _ -> c::Nil #Solo se 32 <= fromEnum c <= 126

    inst Show Chr {
        def show = \c -> Cons '\'' (escapeChr c) ++ ('\''::Nil)
    }

    inst Show (List Chr) {
        def show = \l -> Cons '"' (foldl (\s, c -> s ++ escapeChr c) Nil l) ++ ('"'::Nil)
    }

    def showListAux = \l ->
        put l
        | Nil -> ']' :: Nil
        | Cons x Nil -> show x ++ (']' :: Nil)
        | Cons x xs -> show x ++ Cons ',' (Cons ' ' Nil) ++ showListAux xs

    def showList = \l -> '[' :: showListAux l

    inst forall a. {Show a} => Show (List a) {
        def show = showList
    }

    inst forall a b. {Show a, Show b} => Show (a, b) {
        def show = \(a, b) -> '(' :: show a ++ (','::Nil) ++ show b ++ (')'::Nil)
    }

} use pub Show

mod pub State {
    data pub State s a = State (s -> (a, s))

    inst forall s. Functor (State s) {
        def fmap = \f, State st -> State (\s->
                let (a, s') = st s ->
                    (f a, s')
            )
    }

    inst forall s. Monad (State s) {
        def return = \a -> State(\s -> (a, s))
        def bind = \State st, sf -> State (\s->
                let (a, s') = st s ->
                let State st' = sf a ->
                st' s'
            )
    }

    def pub gets = State (\s->(s, s))
    def pub puts = \ns -> State (\_->((), ns))

    def pub runState = \is, State st -> st is
}

mod IO {
    data pub IO a = IO (State.State RealWorld_ a)

    inst Functor IO {
        def fmap = \f, IO s -> IO (fmap f s)
    }
    inst Monad IO {
        def return = \a -> IO (return a)
        def bind = \IO s, iof -> IO (bind s (\a ->
            let IO b = iof a -> b))
    }

    mod pub UnsafeIO {
        def pub putChr = _putChr
        def pub getChr = _getChr
        def pub putStr : (List Chr, RealWorld_) -> RealWorld_
            = \(s, rw) ->
            put s
            | Nil -> rw
            | Cons c cs ->
                let rw' = putChr (c, rw) ->
                putStr (cs, rw')
        def pub putStrLn = \srw ->
            let rw' = putStr srw ->
            putChr ('\n', rw')
        def pub getLn = \rw ->
            put getChr rw
            | ('\n', rw') -> (Nil, rw')
            | (c, rw') ->
                let (s, rw'') = getLn rw' ->
                (c :: s, rw'')

        def pub runIO = \IO s -> let (a, s') = State.runState RealWorld_ s -> s'
    }

    def pub putChr = \c -> IO(State.State (\s->(() , UnsafeIO.putChr (c,s))))
    def pub getChr = IO(State.State UnsafeIO.getChr)
    def pub putStr = \l -> IO(State.State(\s->((), UnsafeIO.putStr (l,s))))
    def pub putStrLn = \l -> IO(State.State(\s->((), UnsafeIO.putStrLn (l,s))))
    def pub getLn = IO(State.State UnsafeIO.getLn)

    def pub print = show |> putStrLn
} use pub IO
