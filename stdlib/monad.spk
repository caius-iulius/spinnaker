use Core

def mapMAux = \procd, f, l -> put l
    | [] -> return (reverse procd)
    | [x | xs] ->
        a <- f x;
        mapMAux (a :: procd) f xs
def pub mapM : forall m a b. {Monad m} => (a -> m b) -> List a -> m (List b)
    = mapMAux []


rel pub {Monad m} => MonadPlus m =
    # LAWS
    # 1) MONOID
    # 1.1) mplus mzero a = a
    # 1.2) mplus a mzero = a
    # 1.3) mplus (mplus a b) c = mplus a (mplus b c)
    # 2) mzero >>= f = mzero
    # 3) m >> mzero = mzero
    mzero : forall a. m a,
    mplus : forall a. m a -> m a -> m a

def pub guard : forall m. {MonadPlus m} => Bool -> m () =
    \ True -> return ()
    | False -> mzero

inst MonadPlus List {
    def mzero = Nil
    def mplus = (++)
}

rel pub {Monad m} => MonadFail m =
    # Se {MonadPlus m} si puÃ² considerare: mzero = fail "mzero"
    fail : forall a. String -> m a

inst MonadFail IO {
    def fail = error
}

rel pub MonadTrans t = lift : forall m a. {Monad m, Monad (t m)} => m a -> t m a
    # LAWS
    # 1) lift <| return = return
    # 2) lift (m >>= f) = lift m >>= (lift <| f)

mod pub State {
    rel pub {Monad m} => MonadState m s =
        gets : m s,
        puts : s -> m ()

    data pub StateT s m a = StateT (s -> m (a, s))
    def pub runStateT : forall s m a. StateT s m a -> s -> m (a, s)
        = \StateT sf -> sf

    inst forall s f. {Functor f} => Functor (StateT s f) {
        def fmap = \f, StateT sf -> StateT (\s ->
            fmap (\(a, s') -> (f a, s')) (sf s) )
    }

    inst forall s m. {Monad m} => Monad (StateT s m) {
        def return = \a -> StateT (\s -> return (a, s))
        def bind = \StateT sf, f -> StateT (\s ->
            (a, s') <- sf s;
            let StateT sf' = f a ->
            sf' s'
        )
    }

    inst forall s m. {Monad m} => MonadState (StateT s m) s {
        def gets = StateT (\s -> return (s, s))
        def puts = \s -> StateT(const $ return ((), s))
    }

    inst forall s. MonadTrans (StateT s) {
        def lift = \m -> StateT (\s -> fmap (\a -> (a, s)) m)
    }
}
