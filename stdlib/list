use Core

mod Maybe "stdlib/maybe"

def pub head : forall a. List a -> a
    = \Cons x xs -> x
def pub tail : forall a. List a -> List a
    = \Cons x xs -> xs
def pub last : forall a. List a -> a =
    \ [x] -> x
    | [x | xs] -> last xs
def pub init : forall a. List a -> List a =
    \ [x] -> []
    | [x | xs] -> x :: (init xs)

# TODO: uncons, null

def lengthAux = \n, l -> put l
    | [] -> n
    | [_ | xs] -> lengthAux (n + 1) xs
and pub length : forall a. List a -> Int
    = lengthAux 0

def pub foldl : forall a s. (s -> a -> s) -> s -> List a -> s
    = \f, s, l -> put l
    | [] -> s
    | [x | xs] -> foldl f (f s x) xs

def pub foldr : forall s a. (a -> s -> s) -> s -> List a -> s
    = \f, s, l -> put l
    | [] -> s
    | [x | xs] -> f x (foldr f s xs)

# TODO: foldl1, foldr1, scanl, scanr, scanl1, scanr1

# TODO: versione tail-call?
def pub unfoldr : forall a b. (a -> Maybe.Maybe (b, a)) -> a -> List b
    = \f, a -> put f a
    | Maybe.None -> []
    | Maybe.Some (b, a') -> b :: unfoldr f a'

def pub zip : forall a b. List a -> List b -> List (a, b) =
    \ [], _ -> []
    | _, [] -> []
    | Cons x xs, Cons x' xs' -> (x, x') :: zip xs xs'

def pub zipWith : forall a b c. (a -> b -> c) -> List a -> List b -> List c
    = \f, l, l' -> put l, l'
    | [], _ -> []
    | _, [] -> []
    | [x | xs], [x' | xs'] -> f x x' :: zipWith f xs xs'

def pub any : forall a. (a -> Bool) -> List a -> Bool
    = \bf, l -> put l
    | [] -> False
    | [x | xs] -> put bf x
        | True -> True
        | _ -> any bf xs

def pub all : forall a. (a -> Bool) -> List a -> Bool
    = \bf, l -> put l
    | [] -> True
    | [x | xs] -> put bf x
        | False -> False
        | _ -> all bf xs

# TODO: and, or, sum, product, maximum, minimum

def pub elem : forall a. {Eq a} => a -> List a -> Bool
    = \x -> any (x ==)

def pub nth : forall a. Int -> List a -> a
    = \n, l -> put n
    | 0 -> head l
    | _ -> nth (n - 1) (tail l)

def filterAux
    = \c, f, l -> put l
    | [] -> reverse c
    | [x | xs] ->
        let newc = if f x then x :: c else c ->
        filterAux newc f xs
and pub filter: forall a. (a -> Bool) -> List a -> List a
    = filterAux []


# TODO: lookup, find, partition, elemIndex, elemIndices, findIndex, findIndices

# TODO: forse conviene utilizzare una funzione passata come argomento come trasformazione di c e l, oppure reimplementare take e drop autonomamente
def splitAtAux = \c, i, l -> put i, l
    | 0, _ -> (reverse c, l)
    | _, [x | xs] -> splitAtAux (x::c) (i - 1) xs
and pub splitAt : forall a. Int -> List a -> (List a, List a)
    = splitAtAux []

def pub take : forall a. Int -> List a -> List a
    = \i, l -> fst (splitAtAux [] i l)
def pub drop : forall a. Int -> List a -> List a
    = \i, l -> snd (splitAtAux [] i l)

# TODO: takeWhile, dropWhile, span

def pub (\\) : forall a. {Eq a} => List a -> List a -> List a
    = \l, m -> filter (\x -> all (x !=) m) l

# TODO?: inits, tails
# TODO: nub, nubBy, union, unionBy, intersect, intersectBy, insert, insertBy, sort, sortBy, sortOn, delete, deleteBy

def transposeAux =
    \ [l] -> map (::[]) l
    | [l | ls] -> zipWith (::) l (transposeAux ls)
and pub transpose : forall a. List (List a) -> List (List a) =
    \ [] -> []
    | ls -> transposeAux ls

# TODO: intersperse, intercalate, subsequences, permutations, enumerate
