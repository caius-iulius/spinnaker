use pub Core

mod pub Maybe "stdlib/maybe"

mod pub Monad {
    def pub sequence : forall m a. {Monad m} => List (m a) -> m (List a)
        = \lm -> put lm
        | Nil -> return Nil
        | Cons m ms -> m >>= \a -> sequence ms >>= \as -> return (a :: as)

    rel pub {Monad m} => MonadPlus m =
        # LAWS
        # 1) MONOID
        # 1.1) mplus mzero a = a
        # 1.2) mplus a mzero = a
        # 1.3) mplus (mplus a b) c = mplus a (mplus b c)
        # 2) mzero >>= f = mzero
        # 3) m >> mzero = mzero
        mzero : forall a. m a,
        mplus : forall a. m a -> m a -> m a

    def pub guard : forall m. {MonadPlus m} => Bool -> m ()
        = \b -> put b
        | True -> return ()
        | False -> mzero

    inst MonadPlus List {
        def mzero = Nil
        def mplus = (++)
    }

    rel pub {Monad m} => MonadFail m =
        # Se {MonadPlus m} si puÃ² considerare: mzero = fail "mzero"
        fail : forall a. List Chr -> m a

    inst MonadFail IO {
        def fail = error
    }
}

def pub max : forall a. {Ord a} => a -> a -> a
    = \a, b -> put a > b
    | True -> a
    | False -> b
def pub any : forall a. (a -> Bool) -> List a -> Bool
    = \bf, l -> put l
    | Nil -> False
    | Cons x xs -> put bf x
        | True -> True
        | _ -> any bf xs
def pub elem : forall a. {Eq a} => a -> List a -> Bool
    = \x -> any (x ==)
def pub nth : forall a. Int -> List a -> a
    = \n, l -> put n
    | 0 -> head l
    | _ -> nth (n - 1) (tail l)
def innerdotdot = \from, to ->
    put from >= to
    | True -> Nil
    | _ -> toEnum from :: innerdotdot (from+1) to
def pub (..) : forall a. {Enum a} => a -> a -> List a
    = \from, to ->
        innerdotdot (fromEnum from) (fromEnum to)
def pub (..=) : forall a. {Enum a} => a -> a -> List a
    = \from, to ->
        innerdotdot (fromEnum from) (fromEnum to + 1)
