use Core

rel Functor f =
    fmap : forall a b . (a -> b) -> f a -> f b

rel Monad m =
    return : forall a . a -> m a,
    bind : forall a b . m a -> (a -> m b) -> m b

data Maybe a = None | Some a

inst Functor Maybe {
    def fmap = \f, m -> put m
        | None -> None
        | Some x -> Some (f x)
}

inst Monad Maybe {
    def return = \x -> Some x
    def bind = \m, f -> put m
        | None -> None
        | Some x -> f x
}

inst forall m. {Monad m} => Functor m {
    def fmap = \f, m -> bind m (return <| f)
}

def retfmap # : forall m a b. {Monad m, Functor m} => (a -> b) -> a -> m b 
            = \f -> fmap f <| return

rel MyNum a =
    (+!) : a -> a -> a,
    (-!) : a -> a -> a,
    (*!) : a -> a -> a,
    (/!) : a -> a -> a

inst MyNum Int {
    def (+!) = (+)
    def (*!) = (*)
    def (-!) = (-)
    def (/!) = (/)
}

def double : forall a . {MyNum a} => a -> a
           = \x -> x +! x

def squareplus = \x -> x +! x *! x

def threenplus1 = \x -> 1 +! x *! 3

def mutual1 : forall m x . {MyNum (m x), Functor m} => m x -> m x 
            = \x -> x +! mutual2 x
and mutual2 = \x -> mutual1 (fmap (\x'->x') x)

# TODO: Questo dà errore perché attualmente "put" è polimorfico
# def main =
#     let mySub = (-!) ->
#     putStrLn (show (mySub 69 27))

def main =
    let answerToAll = 69 -! 27 ->
    putStrLn (show answerToAll)
