use Core

rel pub Show a =
    show : a -> List Int

rel Functor f =
    fmap : forall a b . (a -> b) -> f a -> f b

rel Monad m =
    return : forall a . a -> m a,
    bind : forall a b . m a -> (a -> m b) -> m b

data Maybe a = None | Some a

inst Functor Maybe {
    def fmap = \f, m -> put m
        | None -> None
        | Some x -> Some (f x)
}

inst Monad Maybe {
    def return = \x -> Some x
    def bind = \m, f -> put m
        | None -> None
        | Some x -> f x
}

inst forall a b. {Show a, Show b} => Show (a, b) {
    def show = \(a, b) -> "(" ++ show a ++ ", " ++ show b ++ ")"
}
inst forall m. {Monad m} => Functor m {
    def fmap = \f, m -> bind m (return <| f)
}

def retfmap # : forall m a b. {Monad m, Functor m} => (a -> b) -> a -> m b 
            = \f -> fmap f <| return

def showTuple = \a, b -> show (a, b)

rel Num a =
    (+!) : a -> a -> a,
    (-!) : a -> a -> a,
    (*!) : a -> a -> a,
    (/!) : a -> a -> a

inst Num Int {
    def (+!) = (+)
    def (*!) = (*)
    def (-!) = (-)
    def (/!) = (/)
}

def double : forall a . {Num a, Show a} => a -> a
           = \x -> x +! x

def squareplus = \x -> x +! x *! x

def threenplus1 = \x -> 1 +! x *! 3

# def mutual1 = \x -> x +! mutual2 x
# and mutual2 = \x -> mutual1 (fmap (\x'->x') x)

def main = ()
