implementa il parsing dei pattern (LABEL@PATTERN), tipo haskell. La rappresentazione interna dei pattern è già stata predisposta per questo
phantom types per determinare se un programma è stato tipizzato?

invece di usare def...and... per le definizioni di valore coricorsive, si può considerare la costrazione di un digrafo dove le frecce sono le possibili chiamate da una funzione del toplevel a un'altra, dopodiché si può usare un algoritmo (per esempio kosaraju) per trovare i cicli e tipizzarli monomorficamente


CONTROLLO DELLE DEFINIZIONI RICORSIVE:
"def x = x" NON DEVE ESSERE PERMESSO
Si può tentare il sistema di tipizzazione di ocaml, permettere solo valori di funzioni oppure utilizzare un contesto di funzioni già "computate"

prendi una decisione riguardo all'ambiguità sintattica del pattern matching

STUDIA K-NORMAL FORMS E A-NORMAL FORMS, SE NON ORA USA UNA DI QUESTE NEL PROSSIMO COMPILATORE

DIMOSTRA IL TYPER, SPECIALMENTE LE REGOLE DEI PATTERN

Il lexer fa casini coi numeri di colonna(forse anche linea) dopo i caratteri speciali. Non è detto che la gestione dei caratteri al momento sia corretta

supporto multifile
incorpora file core
implementa caratteri e completa le stringhe

1. [OK] cosotruttori sempre completamente applicati (Cons --> \a0, a1 -> Cons a0 a1)
2. typing typeclass / typerel
3. monomorfizzazione e scelta dei typeclass
4. notazione do
5. defunzionalizzazione in supercombinatori
    K-Normal o A-Normal form
    Semplificazione a un branch per putexpr
6. compilazione a C
7. ottimizzazioni su HLExpr
