TODO, NOTE e FIXME non sono evidenziati per qualche motivo

Inlining più furbo degli apply: al momento uso la tag inline per suggerire, ma non è determinata (segue comunque inlineHeuristic). se fosse determinata in certi casi la dimensione del codice esploderebbe
l'optimizer ha dei bug se ci sono label ripetute che interagiscono fra loro, non so come
a quanto pare (l'esecuzone lazy non lo fa capire bene) l'optimizer è lentissimo, considera riscrittura?

i typesyn sono implementati alla cazzo
vengono sostituiti durante il demod, quindi senza controlli di kind, devono ricevere sempre l'esatto numero di argomenti richiesti consecutivamente e impediscono i controlli di posizione nelle rel
--- Esempi:
data A a b = A a b
typesyn B a b = A a b
typesyn C = A

todo : (B Int Flt) # funziona
todo : (B Int) Flt # non funziona
todo : (B) Int Flt # non funziona

todo : (C Int Flt) # non funziona
todo : (C Int) Flt # non funziona
todo : (C) Int Flt # funziona
---

i typesyn vanno bene come shorthand, ma bisogna studiare le type families per decidere se esprimere tutto in funzione di quelle, quindi aggiungendole al sistema
il vantaggio di questo sistema è che dopo il demod nessun componente del compilatore deve implementare typesyn

---

aggiungi check di input nella libreria standard, tipo esponenti negativi, liste vuote con head e tail...

dato che i put possono fare matching su più espressioni, potrebbe convenire implementare i let con più assegnazioni:
let v0, v1, v2 = e0, e1, e2 -> e
 |
 v
put e0, e1, e2
| v0, v1, v2 -> e

NOTA: la sintassi del pattern matching è un po' ambigua al momento, le lambda con più match e i put multipat potrebbero soltanto esacerbare il problema

---

implementa il parsing dei pattern (LABEL@PATTERN), tipo haskell. La rappresentazione interna dei pattern è già stata predisposta per questo

invece di usare def...and... per le definizioni di valore coricorsive, si può considerare la costruzione di un digrafo dove le frecce sono le possibili chiamate da una funzione del toplevel a un'altra, dopodiché si può usare un algoritmo (per esempio kosaraju) per trovare i cicli e tipizzarli monomorficamente
alternativamente si può introdurre un vincolo: ogni valore utilizzato prima della sua dichiarazione deve avere un tipo specificato dall'hint. Questo però apre la strada alla ricorsione polimorfica, che andrebbe impedita da qualche altro controllo. Inoltre anche semplici programmi come il fattoriale dovrebbero essere annotati.

prendi una decisione riguardo all'ambiguità sintattica del pattern matching

STUDIA K-NORMAL FORMS E A-NORMAL FORMS, SE NON ORA USA UNA DI QUESTE NEL PROSSIMO COMPILATORE

DIMOSTRA IL TYPER, SPECIALMENTE LE REGOLE DEI PATTERN

SCEGLI UNA SINTASSI MIGLIORE PER "inst" (e forse per i constraint)
Attualmente la sintassi con '{' e '}' va bene, ma sarà ambigua appena implementerò i row types

Il lexer fa casini coi numeri di colonna(forse anche linea) dopo i caratteri speciali. Non è detto che la gestione dei caratteri al momento sia corretta

i file sono implementati in modo inefficiente e fragile (fa compare byte per byte dei contenuti)

1. [OK] cosotruttori sempre completamente applicati (Cons --> \a0, a1 -> Cons a0 a1)
2. typing typerel
    - [OK] risoluzione dei kind nei rel
    - [OK] aggiunta dei rel e delle definizioni dei loro membri nel contesto
    - [OK] entailment ecc. come in THIH
    - [OK] tipizzazione delle espressioni con Qual DataType
    - [OK] gestione dell'hinting e dei predicati nei gruppi di valdef
    - [OK] tipizzazione istanze
    - [OK] riscrivi l'interprete per propagare i tipi e scegliere da vtable
    - [TEST] implementa un sistema di superrel (come le superclass di Haskell)
        - il controllo forse è effettuato troppo tardi
    - aggiungi feedback e test migliori per quando
        - due istanze hanno gli head identici
        - un predicato non ha un'istanza più specifica
        - un predicato è free
    - aggiungi controlli per limitare overlap
        - rilevamento istanze identiche
        - [OK] le istanze devono trattare una relazione o un tipo definiti nel proprio modulo
3. aggiungi controlli per halting del compilatore
    - controlla decidibilità delle istanze (forse non si può fare)
    - controlla valori reciprocamente definiti (e.g. def a = b and b = a) (sia in bindgroup che tra istanze)
4. monomorfizzazione
    - [OK] valori, relazioni
    - datatype (come fa MLTon, selettiva sulle varianti usate)
5. [TEST] notazione bind, il parser per i pattern non va in fatal quando forse dovrebbe, serve per accomodare il parsing dei bind semplici
6. [TEST] defunzionalizzazione
7. ottimizzazioni (guarda il video di SPJ "Haskell in 9 constructors")
    - [TEST] inlining globale
    - [TEST] inlining locale
        forse restringi l'inline a espressioni-valore, cioè label, lambda, costruttori di espressioni-valore...
    - putofput
    - [TEST] application
8. compilazione a C
